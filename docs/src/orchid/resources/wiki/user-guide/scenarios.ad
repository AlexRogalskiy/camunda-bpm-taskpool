---

title: Taskpool Usage Scenarios

---

== Usage Scenarios

Depending on your requirements and infrastructure available several deployment scenarios of the components is possible.

One of the challenging issues for distribution and connecting microservices is a setup of messaging technology supporting required
message exchange patterns (MEPs) for a CQRS system. Because of different semantics of commands, events and queries and additional
requirements of event-sourced persistence a special implementation of command bus, event bus and event store are required.

=== Axon Server Scenario

Axon Server provides such implementation leading to a distributed command and event-bus and a central event store. It is easy
to use, easy to configure and easy to run. If you need a HA setup, you will need the enterprise license of Axon Server. Essentially,
if don't have another HA ready-to use messaging, this scenario might be your way to go.

This scenario supports:

-  central task pool / data pool
-  view must not have a persistent storage (can be replayed)
-  no direct communication between task list and engine is required (routed via command bus)

The following diagram depicts the distribution of the components and the messaging.

image::{{baseUrl('assets/media/deployment-axon-server.png')}}["Deployment of taskpool with axon server"]

=== Scenario without Axon Server

If you already have another messaging at place, like Kafka or RabbitMQ, you might skip the usage of Axon Server. In doing so,
you will be responsible for distribution of events and will need to surrender some features.

This scenario supports:

-  distributed task pool / data pool
-  view must be persistent
-  direct communication between task list / engines required (addressing, routing)
-  concurrent access to engines might become a problem (no unit of work guarantees)

The following diagram depicts the distribution of the components and the messaging.

image::{{baseUrl('assets/media/deployment-messaging.png')}}["Deployment of taskpool with other messaging"]

The following diagram depicts the task run from Process Application to the end user, consuming it via Tasklist API.

image::{{baseUrl('assets/media/scenario_kafka_messaging_overview.png')}}["Kafka Message Run"]

- The `CamundaEventingEnginePlugin` provided with the Taskpool tracks events in the Camunda engine (e.g. the creation, deletion or modification of a User Task) and makes them available as Spring events.
- The `Taskpool Collector` component listens to those events. It collects all relevant events that happen in a single transaction and registers a transaction synchronization to process them beforeCommit. Just before the transaction is committed, the collected events are accumulated and sent as Axon Commands through the `CommandGateway`.
- The `Taskpool Core` processes those commands and issues Axon Events through the EventGateway which are stored in Axon's database tables within the same transaction.
- The transaction commit finishes. If anything goes wrong before this point, the transaction rolls back and it is as though nothing ever happened.
- In the `Axon Kafka Extension`, a `TrackingEventProcessor` polls for events and sees them as soon as the transaction that created them is committed. It sends each event to Kafka and waits for an acknowledgment from Kafka. If sending fails or times out, the event processor goes into error mode and retries until it succeeds. This can lead to events being published to Kafka more than once but guarantees at-least-once delivery.
- Within the Tasklist API, the `Axon Kafka Extension` polls the events from Kafka and another TrackingEventProcessor forwards them to the `TaskPoolMongoService` where they are processed to update the Mongo DB accordingly.
- When a user queries the Tasklist API for tasks, two things happen: Firstly, the Mongo DB is queried for the current state of tasks for this user and these tasks are returned. Secondly, the Tasklist API subscribes to any changes to the Mongo DB. These changes are filtered for relevance to the user and relevant changes are returned after the current state as an infinite stream until the request is cancelled or interrupted for some reason.

image::{{baseUrl('assets/media/scenario_kafka_messaging_tx_view.png')}}["Kafka Message Transaction Overview"]

==== From Process Application to Kafka

image::{{baseUrl('assets/media/scenario_process_application_to_kafka_detail.png')}}["Process Application to Kafka Messaging"]

==== From Kafka to Tasklist API

image::{{baseUrl('assets/media/scenario_kafka_to_tasklist_detail.png')}}["Kafka to Tasklist API Messaging"]
