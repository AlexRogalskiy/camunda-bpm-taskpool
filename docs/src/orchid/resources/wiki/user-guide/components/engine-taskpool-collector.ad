---
title: Taskpool Collector
pageId: engine-datapool-collector
---

== {{ page.title }}


=== Purpose

Taskpool Collector is a component usually deployed as a part of the process application
(aside with Camunda BPM Engine) that is responsible for collecting Spring events fired by
the Camunda Engine Eventing Plugin and creating the corresponding commands for the taskpool.
In doing so, it collects and enriches data and transmits it to Taskpool Core.

In the following description, we use the term _event_ and _command_. Event denotes a data entity
received from Camunda BPM Engine (from delegate event listener or from history event listener)
which is passed over to the Task Collector using internal Spring eventing mechanism. The Task Collector
converts the series of such events into an Taskpool Engine Command - an entity carrying an intent
of change inside of the taskpool core.

=== Features

- Collection of task events and history events
- Creation of corresponding task engine commands
- Enrichment of task engine commands with process variables
- Attachment of correlation information to task engine commands
- Transmission of task engine commands
- Provision of properties for process application

=== Architecture

[ditaa]
----

 +---------+      +-------------+     +---------+     +--------------+     +-----------+
 |         |      |             |     |         |     |    Task      |     |           |
 | Camunda +-=--->+    Event    +-=---|  Task   +-=-->+   Command    +---->+  Command  |
 |  Event  |      |  Collector  |     | Command |     |   Enricher   |     |   Sender  |
 |     {d} |      |             |     |     {d} |     |   Service    |     |           |
 +---------+      +-------------+     +---------+     +--+-------+---+     +-----------+
                                                         :       ^
                                                         |       :
                                                         V       |
                                                      +--+-------+--+
                                                      |             |
                                                      |   Enricher  |
                                                      |             |
                                                      +-------------+

----

The Taskpool Collector consists of several components:

- Event collector receives Spring Events from `camunda-eventing-engine-plugin` and forms commands
- Enricher performs the command enrichment with payload and data correlation
- Command sender is responsible for accumulating commands and sending them to Command Gateway


=== Usage and configuration

In order to enable collector component, include the Maven dependency to your process application:

[source,xml]

----

<dependency>
  <groupId>io.holunda.taskpool<groupId>
  <artifactId>camunda-bpm-taskpool-collector</artifactId>
  <version>${camunda-taskpool.version}</version>
<dependency>

----

Then activate the taskpool collector by providing the annotation on any Spring Configuration:

[source,java]
----

@Configuration
@EnableDataEntryCollector
class MyDataCollectorConfiguration {

}

----



=== Event collection

Taskpool collector registers Spring Event Listener to the following events, fired by Camunda Eventing Engine Plugin:

* `DelegateTask` events:
** create
** assign
** delete
** complete
* `HistoryEvent` events:
** HistoricTaskInstanceEvent
** HistoricIdentityLinkLogEvent


=== Task commands enrichment

Alongside with data attributes received from the Camunda BPM engine, the task engine commands
can be enriched with additional business data. There are three enrichment modes available controlled
by the `camunda.taskpool.collector.enricher.type` property:

* `no`: No enrichment takes place
* `process-variables`: Enrichment with process variables
* `custom`: User provides own implementation

==== Process variable enrichment

In particular cases, the task related data is not sufficient for the information required in task list or
other user-related components. The information may be available as process variables and need to be attached
to the task in the taskpool. This is where _Process Variable Task Enricher_ can be used. For this purpose,
set the property `camunda.taskpool.collector.enricher.type` to `process-variables` and the enricher will
put all process variables into the task payload (defaults to an empty `EXCLUDE` filter).

You can control what variables will be put into task command payload by providing the Process Variables Filter.
The `ProcessVariablesFilter` is a Spring bean holding a list of individual `VariableFilter` - at most one per
process definition key and optionally one without process definition key (a global filter).

A `VariableFilter` can be of the following type:

* `TaskVariableFilter`:
** `INCLUDE`: task-level include filter, denoting a list of variables to be added for the task.
** `EXCLUDE`: task-level exclude filter, denoting a list of variables to be ignored. All other variables are included.
* `ProcessVariableFilter` with process definition key:
** `INCLUDE`: process-level include filter, denoting a list of variables to be added for all tasks of the process.
** `EXCLUDE`: process-level exclude filter, denoting a list of variables to be ignored for all tasks of the process.
* `ProcessVariableFilter` _without_ process definition key:
** `INCLUDE`: global include filter, denoting a list of variables to be added for all tasks of all processes for which no dedicated `ProcessVariableFilter` is defined.
** `EXCLUDE`: global exclude filter, denoting a list of variables to be ignored for all tasks of all processes for which no dedicated `ProcessVariableFilter` is defined.

Here is an example, how the process variable filter can configure the enrichment:

[source,java]
----
  @Configuration
  public class MyTaskCollectorConfiguration {

    @Bean
    public ProcessVariablesFilter myProcessVariablesFilter() {

      return new ProcessVariablesFilter(
        // define a variable filter for every process
        new VariableFilter[]{
          // define for every process definition
          // either a TaskVariableFilter or ProcessVariableFilter
          new TaskVariableFilter(
            ProcessApproveRequest.KEY,
            // filter type
            FilterType.INCLUDE,
            ImmutableMap.<String, List<String>>builder()
              // define a variable filter for every task of the process
              .put(ProcessApproveRequest.Elements.APPROVE_REQUEST, Lists.newArrayList(
                ProcessApproveRequest.Variables.REQUEST_ID,
                ProcessApproveRequest.Variables.ORIGINATOR)
              )
              // and again
              .put(ProcessApproveRequest.Elements.AMEND_REQUEST, Lists.newArrayList(
                ProcessApproveRequest.Variables.REQUEST_ID,
                ProcessApproveRequest.Variables.COMMENT,
                ProcessApproveRequest.Variables.APPLICANT)
              ).build()
          ),
          // optionally add a global filter for all processes
          // for that no individual filter was created
          new ProcessVariableFilter(FilterType.INCLUDE,
            Lists.newArrayList(CommonProcessVariables.CUSTOMER_ID))
        }
      );
    }

  }
----

TIP: If you want to implement a custom enrichment, please provide your own implementation of the interface `VariablesEnricher`
(register a Spring Component of the type) and set the property `camunda.taskpool.collector.enricher.type` to `custom`.


=== Data Correlation

Apart from task payload attached by the enricher, the so-called _Correlation_ with data entries can
be configured. The idea is to attach one or several references (that is `entryType` and `entryId`) to
business data entry(ies) to a task. In a view projection this correlations can be resolved and the
information from business data events can be shown together with task information.

The correlation to data events can be configured by providing a `ProcessVariablesCorrelator`. Here is
an example how this can be done:

[source, kotlin]
----
@Bean
open fun processVariablesCorrelator() = ProcessVariablesCorrelator(

  ProcessVariableCorrelation(ProcessApproveRequest.KEY, <1>
    mapOf(
      ProcessApproveRequest.Elements.APPROVE_REQUEST to mapOf( <2>
        ProcessApproveRequest.Variables.REQUEST_ID to BusinessDataEntry.REQUEST
      )
    ),
    mapOf(ProcessApproveRequest.Variables.REQUEST_ID to BusinessDataEntry.REQUEST) <3>
  )
)
----
<1> define correlation for every process
<2> define a correlation for every task needed
<3> define a correlation globally (for the whole process)

The process variable correlator holds a list of process variable correlations - one for every process
definition key. Every `ProcessVariableCorrelation` configures global (that is for every task) or task correlation
(for particular task definition key) by providing a correlation map. A correlation map is keyed by the
Camunda Process Variable Name and holds business data Entry Type as value.

Here is an example. Imagine the process instance is storing the id of an approval request in a process variable called
`varRequestId`. The system responsible for storing approval requests fires data entry events supplying the
data and using the entry type `approvalRequest` and the id of the request as `entryId`. In order to
create a correlation in task `task_approve_request` of the `process_approval_process` we would provide the following configuration
of the correlator:

[source,kotlin]
----
@Bean
open fun processVariablesCorrelator() = ProcessVariablesCorrelator(

  ProcessVariableCorrelation("process_approval_process",
    mapOf(
      "task_approve_request" to mapOf(
        "varRequestId" to "approvalRequest"
      )
    )
  )
)
----
If the process instance now contains the approval request id `"4711"` in the process variable `varRequestId`
and the process reaches the task `task_approve_request`, the task will get the following correlation created
(here written in JSON):

[source,json]
----
"correlations": [
  { "entryType": "approvalRequest", "entryId": "4711" }
]
----

=== Command transmission

In order to control sending of commands to command gateway, the command sender activation property
`camunda.taskpool.collector.sender.enabled` (default is `true`) is available. If disabled, the command sender
will log any command instead of sending it to the command gateway.

In addition you can control by the property `camunda.taskpool.collector.sender.type` if you want to use the default command sender or provide your own implementation.
The default provided command sender (type: `tx`) is collects all task commands during one transaction, group them by task id
and accumulates by creating one command reflecting the intent of the task operation. It uses Axon Command Bus (encapsulated
by the `AxonCommandListGateway`.

TIP: If you want to implement a custom command sending, please provide your own implementation of the interface `CommandSender`
(register a Spring Component of the type) and set the property `camunda.taskpool.collector.sender.type` to `custom`.

The Spring event listeners receiving events from the Camunda Engine plugin are called before the engine commits the transaction.
Since all processing inside collector and enricher is performed synchronous, the sender must waits until transaction to
be successfully committed before sending any commands to the Command Gateway. Otherwise, on any error
the transaction would be rolled back and the command would create an inconsistency between the taskpool and the engine.

Depending on your deployment scenario, you may want to control the exact point in time when the commands are send to Command Bus.
The property `camunda.taskpool.collector.sender.send-within-transaction` is designed to influence this. If set to `true`, the commands
are sent _before_ the process engine transaction is committed, otherwise commands are sent _after_ the process engine transaction is committed.

WARNING: Never send commands over remote messaging before the transaction is committed, since you may produce unexpected results if Camunda fails
to commit the transaction.

